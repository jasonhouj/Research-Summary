{
  "name": "Paper Summarizer (Text Input) v2",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "summarize-paper",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Receive Text",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "paper-summarizer-text"
    },
    {
      "parameters": {
        "jsCode": "// Debug: Log what we receive\nconst input = $input.first();\nconsole.log('Raw input:', JSON.stringify(input, null, 2));\n\n// Try multiple ways to access the text (n8n versions differ)\nlet text = '';\nlet fileName = 'Unknown';\n\n// Method 1: Direct json access\nif (input.json && input.json.text) {\n  text = input.json.text;\n  fileName = input.json.fileName || fileName;\n}\n// Method 2: Body wrapper (some n8n versions)\nelse if (input.json && input.json.body && input.json.body.text) {\n  text = input.json.body.text;\n  fileName = input.json.body.fileName || fileName;\n}\n// Method 3: Nested data\nelse if (input.json && input.json.data && input.json.data.text) {\n  text = input.json.data.text;\n  fileName = input.json.data.fileName || fileName;\n}\n\nconsole.log('Extracted text length:', text.length);\nconsole.log('File name:', fileName);\n\nif (!text || text.length === 0) {\n  // Return error info for debugging\n  return [{\n    json: {\n      error: 'No text received',\n      receivedKeys: Object.keys(input.json || {}),\n      receivedData: JSON.stringify(input.json).substring(0, 500)\n    }\n  }];\n}\n\n// Function to extract section content\nfunction extractSection(text, sectionNames, nextSectionNames) {\n  for (const name of sectionNames) {\n    // Try multiple patterns\n    const patterns = [\n      // Numbered: \"1. Introduction\" or \"1 Introduction\"\n      new RegExp(`(?:^|\\\\n)\\\\s*(?:\\\\d+\\\\.?\\\\s*)?${name}\\\\s*\\\\n([\\\\s\\\\S]*?)(?=\\\\n\\\\s*(?:\\\\d+\\\\.?\\\\s*)?(?:${nextSectionNames.join('|')})\\\\s*\\\\n|$)`, 'i'),\n      // Simple: \"Introduction\\n\"\n      new RegExp(`(?:^|\\\\n)${name}\\\\s*\\\\n([\\\\s\\\\S]*?)(?=\\\\n(?:${nextSectionNames.join('|')})\\\\s*\\\\n|$)`, 'i'),\n      // With colon: \"Introduction:\"\n      new RegExp(`${name}\\\\s*:\\\\s*([\\\\s\\\\S]*?)(?=(?:${nextSectionNames.join('|')})|$)`, 'i'),\n      // ALL CAPS\n      new RegExp(`(?:^|\\\\n)${name.toUpperCase()}\\\\s*\\\\n([\\\\s\\\\S]*?)(?=\\\\n(?:${nextSectionNames.map(n => n.toUpperCase()).join('|')})\\\\s*\\\\n|$)`)\n    ];\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern);\n      if (match && match[1] && match[1].trim().length > 100) {\n        return match[1].trim().substring(0, 8000);\n      }\n    }\n  }\n  return null;\n}\n\n// Extract title - try first substantial line\nlet title = fileName.replace('.pdf', '').replace(/[_-]/g, ' ');\nconst lines = text.split('\\n').filter(l => l.trim().length > 10 && l.trim().length < 200);\nif (lines.length > 0) {\n  title = lines[0].trim();\n}\n\n// Extract abstract\nlet abstract = 'Abstract not found';\nconst abstractPatterns = [\n  /abstract\\s*\\n([\\s\\S]{100,3000}?)(?=\\n\\s*(?:keywords|key\\s*words|introduction|background|1\\s*\\.|1\\s+))/i,\n  /abstract\\s*:?\\s*([\\s\\S]{100,3000}?)(?=\\n\\s*(?:keywords|introduction|1\\.))/i\n];\nfor (const pattern of abstractPatterns) {\n  const match = text.match(pattern);\n  if (match && match[1]) {\n    abstract = match[1].trim();\n    break;\n  }\n}\n\nconst sectionConfig = {\n  introduction: {\n    names: ['introduction', 'background', 'overview', 'literature review', 'context'],\n    next: ['method', 'methods', 'methodology', 'materials and methods', 'materials & methods', 'experimental', 'study design', 'participants', '2', '2\\\\.']\n  },\n  methods: {\n    names: ['methods', 'method', 'methodology', 'materials and methods', 'materials & methods', 'experimental', 'study design', 'participants', 'procedures'],\n    next: ['results', 'result', 'findings', 'outcomes', 'data', 'analysis', '3', '3\\\\.']\n  },\n  results: {\n    names: ['results', 'result', 'findings', 'outcomes', 'data', 'analysis'],\n    next: ['discussion', 'interpretation', 'implications', 'comments', '4', '4\\\\.']\n  },\n  discussion: {\n    names: ['discussion', 'interpretation', 'implications', 'general discussion'],\n    next: ['conclusion', 'conclusions', 'summary', 'limitations', 'future', '5', '5\\\\.']\n  },\n  conclusion: {\n    names: ['conclusion', 'conclusions', 'summary', 'concluding remarks', 'final remarks'],\n    next: ['references', 'bibliography', 'acknowledgment', 'acknowledgement', 'conflict', 'disclosure', 'funding', 'author']\n  },\n  conflictOfInterest: {\n    names: ['conflict of interest', 'conflicts of interest', 'competing interests', 'disclosure', 'disclosures', 'declaration'],\n    next: ['references', 'bibliography', 'acknowledgment', 'funding', 'author', 'supplementary']\n  }\n};\n\nconst sections = {};\nfor (const [key, config] of Object.entries(sectionConfig)) {\n  sections[key] = extractSection(text, config.names, config.next);\n}\n\n// Log found sections for debugging\nconst foundSections = Object.entries(sections).filter(([k, v]) => v !== null).map(([k]) => k);\nconsole.log('Found sections:', foundSections);\n\nreturn [{\n  json: {\n    title,\n    abstract,\n    sections: {\n      introduction: sections.introduction || 'Section not found in document.',\n      methods: sections.methods || 'Section not found in document.',\n      results: sections.results || 'Section not found in document.',\n      discussion: sections.discussion || 'Section not found in document.',\n      conclusion: sections.conclusion || 'Section not found in document.',\n      conflictOfInterest: sections.conflictOfInterest || 'No conflict of interest section found.'\n    },\n    sectionsFound: {\n      introduction: !!sections.introduction,\n      methods: !!sections.methods,\n      results: !!sections.results,\n      discussion: !!sections.discussion,\n      conclusion: !!sections.conclusion,\n      conflictOfInterest: !!sections.conflictOfInterest\n    },\n    fullTextLength: text.length\n  }\n}];"
      },
      "id": "parse-sections",
      "name": "Parse Paper Sections",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-error",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-error",
      "name": "Check for Error",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: false, error: $json.error, debug: { receivedKeys: $json.receivedKeys, sample: $json.receivedData } } }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "application/json" }
            ]
          }
        }
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 200]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst sections = data.sections;\nconst sectionsFound = data.sectionsFound;\n\nconst prompts = [\n  { key: 'introduction', name: 'Introduction', found: sectionsFound.introduction,\n    prompt: sectionsFound.introduction ? `Summarize this Introduction in 2-3 paragraphs (150-250 words). Focus on research problem, objectives, significance.\\n\\n${sections.introduction}` : 'Respond with exactly: Introduction section not found in the document.' },\n  { key: 'methods', name: 'Methods', found: sectionsFound.methods,\n    prompt: sectionsFound.methods ? `Summarize this Methods section in 2-3 paragraphs (150-250 words). Focus on study design, participants, procedures, analysis.\\n\\n${sections.methods}` : 'Respond with exactly: Methods section not found in the document.' },\n  { key: 'results', name: 'Results', found: sectionsFound.results,\n    prompt: sectionsFound.results ? `Summarize this Results section in 2-3 paragraphs (150-250 words). Focus on main findings, statistics, patterns.\\n\\n${sections.results}` : 'Respond with exactly: Results section not found in the document.' },\n  { key: 'discussion', name: 'Discussion', found: sectionsFound.discussion,\n    prompt: sectionsFound.discussion ? `Summarize this Discussion in 2-3 paragraphs (150-250 words). Focus on interpretation, implications, limitations.\\n\\n${sections.discussion}` : 'Respond with exactly: Discussion section not found in the document.' },\n  { key: 'conclusion', name: 'Conclusion', found: sectionsFound.conclusion,\n    prompt: sectionsFound.conclusion ? `Summarize this Conclusion in 1-2 paragraphs (75-150 words). Focus on main takeaways, implications.\\n\\n${sections.conclusion}` : 'Respond with exactly: Conclusion section not found in the document.' },\n  { key: 'conflictOfInterest', name: 'Conflict of Interest', found: sectionsFound.conflictOfInterest,\n    prompt: sectionsFound.conflictOfInterest ? `Extract conflict of interest info in 2-4 sentences. Include declared conflicts, funding.\\n\\n${sections.conflictOfInterest}` : 'Respond with exactly: No conflict of interest information found.' }\n];\n\nconst metadata = { title: data.title, abstract: data.abstract, fullTextLength: data.fullTextLength, sectionsFound };\n\nreturn prompts.map(p => ({ json: { ...p, metadata } }));"
      },
      "id": "prepare-prompts",
      "name": "Prepare AI Prompts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "loop-sections",
      "name": "Loop Over Sections",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "prompt": "={{ $json.prompt }}",
        "options": {}
      },
      "id": "basic-llm-chain",
      "name": "Basic LLM Chain",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.4,
      "position": [1340, 400]
    },
    {
      "parameters": {
        "modelName": "models/gemini-1.5-flash",
        "options": {
          "temperature": 0.3,
          "maxOutputTokens": 500
        }
      },
      "id": "gemini-model",
      "name": "Google Gemini Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [1340, 620]
    },
    {
      "parameters": {
        "jsCode": "const inputData = $('Loop Over Sections').first().json;\nconst aiResponse = $input.first().json;\n\nlet summary = aiResponse.text || aiResponse.response?.text || (typeof aiResponse === 'string' ? aiResponse : JSON.stringify(aiResponse));\n\nreturn [{ json: { key: inputData.key, name: inputData.name, summary, found: inputData.found, metadata: inputData.metadata } }];"
      },
      "id": "extract-response",
      "name": "Extract AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 400]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-summaries",
      "name": "Aggregate All Summaries",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1780, 400]
    },
    {
      "parameters": {
        "jsCode": "const allData = $input.first().json.data;\n\nconst response = {\n  success: true,\n  paper: { title: '', abstract: '' },\n  summaries: { introduction: 'Not available', methods: 'Not available', results: 'Not available', discussion: 'Not available', conclusion: 'Not available', conflictOfInterest: 'Not available' },\n  sectionsFound: { introduction: false, methods: false, results: false, discussion: false, conclusion: false, conflictOfInterest: false },\n  metadata: { generatedAt: new Date().toISOString(), sectionsProcessed: 0, sectionsSuccessfullyFound: 0, fullTextLength: 0, aiModel: 'Google Gemini 1.5 Flash' }\n};\n\nfor (const item of allData) {\n  if (item.key && item.summary) {\n    response.summaries[item.key] = item.summary;\n    response.sectionsFound[item.key] = item.found || false;\n    response.metadata.sectionsProcessed++;\n    if (item.found) response.metadata.sectionsSuccessfullyFound++;\n  }\n  if (item.metadata && !response.paper.title) {\n    response.paper.title = item.metadata.title || 'Unknown';\n    response.paper.abstract = item.metadata.abstract || 'Not found';\n    response.metadata.fullTextLength = item.metadata.fullTextLength || 0;\n  }\n}\n\nreturn [{ json: response }];"
      },
      "id": "compile-response",
      "name": "Compile Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "application/json" },
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2220, 400]
    },
    {
      "parameters": {
        "content": "## Paper Summarizer v2\n\n**Receives JSON:** `{ \"text\": \"...\", \"fileName\": \"...\" }`\n\n**IMPORTANT:**\n1. Connect Gemini Chat Model to Basic LLM Chain's AI input\n2. Configure your Gemini API credentials\n\nDebugging: Check Parse Paper Sections output to see extracted sections",
        "height": 200,
        "width": 350,
        "color": 4
      },
      "id": "sticky-note",
      "name": "Instructions",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [240, 60]
    }
  ],
  "connections": {
    "Webhook - Receive Text": {
      "main": [[{ "node": "Parse Paper Sections", "type": "main", "index": 0 }]]
    },
    "Parse Paper Sections": {
      "main": [[{ "node": "Check for Error", "type": "main", "index": 0 }]]
    },
    "Check for Error": {
      "main": [
        [{ "node": "Error Response", "type": "main", "index": 0 }],
        [{ "node": "Prepare AI Prompts", "type": "main", "index": 0 }]
      ]
    },
    "Prepare AI Prompts": {
      "main": [[{ "node": "Loop Over Sections", "type": "main", "index": 0 }]]
    },
    "Loop Over Sections": {
      "main": [
        [{ "node": "Basic LLM Chain", "type": "main", "index": 0 }],
        [{ "node": "Aggregate All Summaries", "type": "main", "index": 0 }]
      ]
    },
    "Basic LLM Chain": {
      "main": [[{ "node": "Extract AI Response", "type": "main", "index": 0 }]]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [[{ "node": "Basic LLM Chain", "type": "ai_languageModel", "index": 0 }]]
    },
    "Extract AI Response": {
      "main": [[{ "node": "Loop Over Sections", "type": "main", "index": 0 }]]
    },
    "Aggregate All Summaries": {
      "main": [[{ "node": "Compile Final Response", "type": "main", "index": 0 }]]
    },
    "Compile Final Response": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" }
}
