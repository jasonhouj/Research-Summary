{
  "name": "Scientific Research Paper Summarizer (Gemini) - Fixed",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "summarize-paper",
        "responseMode": "responseNode",
        "options": {
          "binaryData": true
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook - Receive PDF",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "research-paper-summarizer"
    },
    {
      "parameters": {
        "operation": "extractFromPdf",
        "binaryPropertyName": "data",
        "options": {}
      },
      "id": "extract-pdf-text",
      "name": "Extract PDF Text",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse sections from scientific research paper with EXPANDED section name variations\nconst text = $input.first().json.text || $input.first().json.data || '';\n\n// Function to extract section content between headers\nfunction extractSection(text, sectionNames, nextSectionNames) {\n  for (const name of sectionNames) {\n    const patterns = [\n      new RegExp(`(?:^|\\\\n)\\\\s*(?:\\\\d+\\\\.?\\\\s*)?${name}[:\\\\s]*\\\\n([\\\\s\\\\S]*?)(?=\\\\n\\\\s*(?:\\\\d+\\\\.?\\\\s*)?(?:${nextSectionNames.join('|')})[:\\\\s]*\\\\n|$)`, 'i'),\n      new RegExp(`(?:^|\\\\n)${name}[:\\\\s]*\\\\n([\\\\s\\\\S]*?)(?=\\\\n(?:${nextSectionNames.join('|')})[:\\\\s]*\\\\n|$)`, 'i'),\n      new RegExp(`${name}[:\\\\s]*([\\\\s\\\\S]*?)(?=(?:${nextSectionNames.join('|')})|$)`, 'i'),\n      new RegExp(`(?:^|\\\\n)${name.toUpperCase()}[:\\\\s]*\\\\n([\\\\s\\\\S]*?)(?=\\\\n(?:${nextSectionNames.map(n => n.toUpperCase()).join('|')})[:\\\\s]*\\\\n|$)`, 'i'),\n      new RegExp(`(?:^|\\\\n)\\\\s*(?:[IVX]+\\\\.?\\\\s*)?${name}[:\\\\s]*\\\\n([\\\\s\\\\S]*?)(?=\\\\n\\\\s*(?:[IVX]+\\\\.?\\\\s*)?(?:${nextSectionNames.join('|')})[:\\\\s]*\\\\n|$)`, 'i')\n    ];\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern);\n      if (match && match[1] && match[1].trim().length > 50) {\n        return match[1].trim().substring(0, 10000);\n      }\n    }\n  }\n  return null;\n}\n\nlet title = 'Title not found';\nconst titlePatterns = [\n  /^([^\\n]{10,200})/m,\n  /title[:\\s]*([^\\n]{10,200})/i,\n];\nfor (const pattern of titlePatterns) {\n  const match = text.match(pattern);\n  if (match && match[1]) {\n    title = match[1].trim();\n    break;\n  }\n}\n\nlet abstract = 'Abstract not found';\nconst abstractPatterns = [\n  /abstract[:\\s]*\\n([\\s\\S]{100,4000}?)(?=\\n\\s*(?:keywords|key words|introduction|background|1\\.|\\n\\n\\n))/i,\n  /abstract[:\\s]*([\\s\\S]{100,4000}?)(?=\\n\\s*(?:keywords|introduction|background|1\\.))/i,\n  /summary[:\\s]*\\n([\\s\\S]{100,4000}?)(?=\\n\\s*(?:keywords|introduction|background|1\\.))/i\n];\nfor (const pattern of abstractPatterns) {\n  const match = text.match(pattern);\n  if (match && match[1]) {\n    abstract = match[1].trim();\n    break;\n  }\n}\n\nconst sectionConfig = {\n  introduction: {\n    names: ['introduction', 'background', 'overview', 'literature review', 'context', 'rationale', 'motivation'],\n    next: ['method', 'methods', 'methodology', 'materials and methods', 'experimental', 'study design', 'procedures', '2\\\\.']\n  },\n  methods: {\n    names: ['methods', 'method', 'methodology', 'materials and methods', 'experimental', 'study design', 'procedures', 'data collection'],\n    next: ['results', 'result', 'findings', 'outcomes', 'observations', 'evaluation', '3\\\\.']\n  },\n  results: {\n    names: ['results', 'result', 'findings', 'outcomes', 'observations', 'evaluation', 'experiments'],\n    next: ['discussion', 'analysis', 'interpretation', 'implications', '4\\\\.']\n  },\n  discussion: {\n    names: ['discussion', 'analysis', 'interpretation', 'implications', 'significance'],\n    next: ['conclusion', 'conclusions', 'summary', 'limitations', 'future work', '5\\\\.']\n  },\n  conclusion: {\n    names: ['conclusion', 'conclusions', 'summary', 'concluding remarks', 'final remarks'],\n    next: ['references', 'bibliography', 'acknowledgment', 'conflict', 'disclosures', 'funding']\n  },\n  conflictOfInterest: {\n    names: ['conflict of interest', 'conflicts of interest', 'competing interests', 'disclosures', 'declaration of interest'],\n    next: ['references', 'bibliography', 'acknowledgment', 'funding', 'appendix']\n  }\n};\n\nconst sections = {};\nfor (const [key, config] of Object.entries(sectionConfig)) {\n  sections[key] = extractSection(text, config.names, config.next);\n}\n\nreturn [{\n  json: {\n    title: title,\n    abstract: abstract,\n    sections: {\n      introduction: sections.introduction || 'Section not found.',\n      methods: sections.methods || 'Section not found.',\n      results: sections.results || 'Section not found.',\n      discussion: sections.discussion || 'Section not found.',\n      conclusion: sections.conclusion || 'Section not found.',\n      conflictOfInterest: sections.conflictOfInterest || 'No conflict of interest section found.'\n    },\n    sectionsFound: {\n      introduction: !!sections.introduction,\n      methods: !!sections.methods,\n      results: !!sections.results,\n      discussion: !!sections.discussion,\n      conclusion: !!sections.conclusion,\n      conflictOfInterest: !!sections.conflictOfInterest\n    },\n    fullTextLength: text.length\n  }\n}];"
      },
      "id": "parse-sections",
      "name": "Parse Paper Sections",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst sections = data.sections;\nconst sectionsFound = data.sectionsFound;\n\nconst sectionPrompts = [\n  { sectionKey: 'introduction', sectionName: 'Introduction', wasFound: sectionsFound.introduction,\n    prompt: sectionsFound.introduction ? `Summarize this Introduction section in 2-3 paragraphs (150-250 words). Focus on: research problem, objectives, significance.\\n\\n${sections.introduction}` : 'Respond: Introduction section not found.' },\n  { sectionKey: 'methods', sectionName: 'Methods', wasFound: sectionsFound.methods,\n    prompt: sectionsFound.methods ? `Summarize this Methods section in 2-3 paragraphs (150-250 words). Focus on: study design, participants, procedures, analysis methods.\\n\\n${sections.methods}` : 'Respond: Methods section not found.' },\n  { sectionKey: 'results', sectionName: 'Results', wasFound: sectionsFound.results,\n    prompt: sectionsFound.results ? `Summarize this Results section in 2-3 paragraphs (150-250 words). Focus on: main findings, key statistics, patterns.\\n\\n${sections.results}` : 'Respond: Results section not found.' },\n  { sectionKey: 'discussion', sectionName: 'Discussion', wasFound: sectionsFound.discussion,\n    prompt: sectionsFound.discussion ? `Summarize this Discussion section in 2-3 paragraphs (150-250 words). Focus on: interpretation, comparison to prior research, implications, limitations.\\n\\n${sections.discussion}` : 'Respond: Discussion section not found.' },\n  { sectionKey: 'conclusion', sectionName: 'Conclusion', wasFound: sectionsFound.conclusion,\n    prompt: sectionsFound.conclusion ? `Summarize this Conclusion section in 1-2 paragraphs (75-150 words). Focus on: main takeaways, implications, future directions.\\n\\n${sections.conclusion}` : 'Respond: Conclusion section not found.' },\n  { sectionKey: 'conflictOfInterest', sectionName: 'Conflict of Interest', wasFound: sectionsFound.conflictOfInterest,\n    prompt: sectionsFound.conflictOfInterest ? `Extract conflict of interest information in 2-4 sentences. Include: declared conflicts, funding sources, competing interests.\\n\\n${sections.conflictOfInterest}` : 'Respond: No conflict of interest section found.' }\n];\n\nconst metadata = { title: data.title, abstract: data.abstract, fullTextLength: data.fullTextLength, sectionsFound: sectionsFound };\n\nreturn sectionPrompts.map(item => ({ json: { ...item, metadata: metadata } }));"
      },
      "id": "prepare-prompts",
      "name": "Prepare AI Prompts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "loop-sections",
      "name": "Loop Over Sections",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "prompt": "={{ $json.prompt }}",
        "options": {}
      },
      "id": "basic-llm-chain",
      "name": "Basic LLM Chain",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.4,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "modelName": "models/gemini-1.5-flash",
        "options": {
          "temperature": 0.3,
          "maxOutputTokens": 500
        }
      },
      "id": "gemini-model",
      "name": "Google Gemini Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [1340, 520],
      "credentials": {
        "googleGeminiApi": {
          "id": "REPLACE_WITH_YOUR_CREDENTIAL_ID",
          "name": "Google Gemini API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const inputData = $('Loop Over Sections').first().json;\nconst aiResponse = $input.first().json;\n\nlet summary = '';\nif (aiResponse.text) {\n  summary = aiResponse.text;\n} else if (aiResponse.response?.text) {\n  summary = aiResponse.response.text;\n} else if (typeof aiResponse === 'string') {\n  summary = aiResponse;\n} else {\n  summary = JSON.stringify(aiResponse);\n}\n\nreturn [{\n  json: {\n    sectionKey: inputData.sectionKey,\n    sectionName: inputData.sectionName,\n    summary: summary,\n    wasFound: inputData.wasFound,\n    metadata: inputData.metadata\n  }\n}];"
      },
      "id": "extract-response",
      "name": "Extract AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-summaries",
      "name": "Aggregate All Summaries",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "jsCode": "const allData = $input.first().json.data;\n\nconst response = {\n  success: true,\n  paper: { title: '', abstract: '' },\n  summaries: {\n    introduction: 'Not available',\n    methods: 'Not available',\n    results: 'Not available',\n    discussion: 'Not available',\n    conclusion: 'Not available',\n    conflictOfInterest: 'Not available'\n  },\n  sectionsFound: {\n    introduction: false, methods: false, results: false,\n    discussion: false, conclusion: false, conflictOfInterest: false\n  },\n  metadata: {\n    generatedAt: new Date().toISOString(),\n    sectionsProcessed: 0,\n    sectionsSuccessfullyFound: 0,\n    fullTextLength: 0,\n    aiModel: 'Google Gemini 1.5 Flash'\n  }\n};\n\nfor (const item of allData) {\n  if (item.sectionKey && item.summary) {\n    response.summaries[item.sectionKey] = item.summary;\n    response.sectionsFound[item.sectionKey] = item.wasFound || false;\n    response.metadata.sectionsProcessed++;\n    if (item.wasFound) response.metadata.sectionsSuccessfullyFound++;\n  }\n  if (item.metadata && !response.paper.title) {\n    response.paper.title = item.metadata.title || 'Title not extracted';\n    response.paper.abstract = item.metadata.abstract || 'Abstract not extracted';\n    response.metadata.fullTextLength = item.metadata.fullTextLength || 0;\n  }\n}\n\nreturn [{ json: response }];"
      },
      "id": "compile-response",
      "name": "Compile Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "application/json" },
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2220, 300]
    },
    {
      "parameters": {
        "content": "## Scientific Research Paper Summarizer (Gemini) - FIXED\n\n### IMPORTANT: Connect the Google Gemini Chat Model!\n\n1. The Gemini model node (below Basic LLM Chain) must be connected to the Basic LLM Chain node\n2. Drag from Gemini's output to the AI Language Model input on Basic LLM Chain\n3. Configure your Google Gemini API credentials",
        "height": 200,
        "width": 400,
        "color": 4
      },
      "id": "sticky-note",
      "name": "Setup Instructions",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [240, -100]
    }
  ],
  "connections": {
    "Webhook - Receive PDF": {
      "main": [[{ "node": "Extract PDF Text", "type": "main", "index": 0 }]]
    },
    "Extract PDF Text": {
      "main": [[{ "node": "Parse Paper Sections", "type": "main", "index": 0 }]]
    },
    "Parse Paper Sections": {
      "main": [[{ "node": "Prepare AI Prompts", "type": "main", "index": 0 }]]
    },
    "Prepare AI Prompts": {
      "main": [[{ "node": "Loop Over Sections", "type": "main", "index": 0 }]]
    },
    "Loop Over Sections": {
      "main": [
        [{ "node": "Basic LLM Chain", "type": "main", "index": 0 }],
        [{ "node": "Aggregate All Summaries", "type": "main", "index": 0 }]
      ]
    },
    "Basic LLM Chain": {
      "main": [[{ "node": "Extract AI Response", "type": "main", "index": 0 }]]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [[{ "node": "Basic LLM Chain", "type": "ai_languageModel", "index": 0 }]]
    },
    "Extract AI Response": {
      "main": [[{ "node": "Loop Over Sections", "type": "main", "index": 0 }]]
    },
    "Aggregate All Summaries": {
      "main": [[{ "node": "Compile Final Response", "type": "main", "index": 0 }]]
    },
    "Compile Final Response": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" }
}
